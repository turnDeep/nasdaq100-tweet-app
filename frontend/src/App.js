import React, { useState, useEffect, useCallback } from 'react';
import Chart from './components/Chart';
import TimeFrameSelector from './components/TimeFrameSelector';
import PositionIndicator from './components/PositionIndicator';
import PostModal from './components/PostModal';
import { WebSocketService } from './services/websocket';
import axios from 'axios';
import './styles/App.css';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

// „Éá„É¢„Éá„Éº„ÇøÁîüÊàêÈñ¢Êï∞
function generateDemoData(timeFrame) {
  const now = Math.floor(Date.now() / 1000);
  const intervals = {
    '1m': 60,
    '3m': 180,
    '5m': 300,
    '15m': 900,
    '1H': 3600,
    '4H': 14400,
    '1D': 86400,
    '1W': 604800
  };
  
  const interval = intervals[timeFrame] || 900;
  const numPoints = 100;
  const data = [];
  let basePrice = 17000;
  
  for (let i = 0; i < numPoints; i++) {
    const time = now - (numPoints - i) * interval;
    const change = (Math.random() - 0.5) * 100;
    const open = basePrice + change;
    const close = open + (Math.random() - 0.5) * 50;
    const high = Math.max(open, close) + Math.random() * 20;
    const low = Math.min(open, close) - Math.random() * 20;
    
    data.push({
      time,
      open: parseFloat(open.toFixed(2)),
      high: parseFloat(high.toFixed(2)),
      low: parseFloat(low.toFixed(2)),
      close: parseFloat(close.toFixed(2)),
      volume: Math.floor(Math.random() * 1000000)
    });
    
    basePrice = close;
  }
  
  return data;
}

// „Éá„É¢„Ç≥„É°„É≥„ÉàÁîüÊàêÔºà„Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÇíÁßíÂçò‰Ωç„ÅßÔºâ
function generateDemoComments() {
  const now = Math.floor(Date.now() / 1000);
  return [
    {
      id: 1,
      timestamp: now - 300,  // 5ÂàÜÂâç
      price: 17100.50,
      content: '„Éä„Çπ„ÉÄ„ÉÉ„ÇØÂº∑Ê∞óÔºÅüöÄ',
      emotion_icon: 'üöÄ'
    },
    {
      id: 2,
      timestamp: now - 900,  // 15ÂàÜÂâç
      price: 17050.25,
      content: '„Åì„ÅÆËæ∫„ÅßË≤∑„ÅÑÂ¢ó„ÅóÊ§úË®é‰∏≠',
      emotion_icon: 'üòä'
    },
    {
      id: 3,
      timestamp: now - 1800,  // 30ÂàÜÂâç
      price: 17150.75,
      content: 'Âà©Á¢∫„Åó„Åæ„Åó„Åü„ÄÇÊßòÂ≠êË¶ã',
      emotion_icon: 'üòé'
    }
  ];
}

function App() {
  const [timeFrame, setTimeFrame] = useState('15m');
  const [comments, setComments] = useState([]);
  const [sentiment, setSentiment] = useState({ buy_percentage: 50, sell_percentage: 50 });
  const [showPostModal, setShowPostModal] = useState(false);
  const [chartData, setChartData] = useState([]);
  const [wsService, setWsService] = useState(null);
  const [selectedCandle, setSelectedCandle] = useState(null);
  const [connectionError, setConnectionError] = useState(false);

  const loadChartData = useCallback(async () => {
    try {
      console.log('Loading chart data for timeframe:', timeFrame);
      
      const res = await axios.get(`${API_URL}/api/market/^NDX/${timeFrame}`, {
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json',
        }
      });
      
      console.log('Chart data loaded:', res.data);
      
      if (res.data.data && res.data.data.length > 0) {
        setChartData(res.data.data);
      }
      setConnectionError(false);
    } catch (error) {
      console.error('Failed to load chart data:', error);
      setConnectionError(true);
      // „Éá„É¢„Éá„Éº„Çø„ÇíË®≠ÂÆö
      const demoData = generateDemoData(timeFrame);
      setChartData(demoData);
    }
  }, [timeFrame]);

  const loadComments = useCallback(async () => {
    try {
      console.log('Loading all comments');
      
      // „Åô„Åπ„Å¶„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÂèñÂæóÔºà„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Å™„ÅóÔºâ
      const commentsRes = await axios.get(`${API_URL}/api/comments`);
      console.log('Comments API response:', commentsRes.data);
      
      if (commentsRes.data.comments) {
        console.log(`Loaded ${commentsRes.data.comments.length} comments`);
        
        // „Éá„Éê„ÉÉ„Ç∞Áî®Ôºö„Ç≥„É°„É≥„Éà„ÅÆË©≥Á¥∞„Çí„É≠„Ç∞
        commentsRes.data.comments.forEach((comment, index) => {
          if (index < 5) { // ÊúÄÂàù„ÅÆ5‰ª∂„Å†„Åë„É≠„Ç∞
            console.log('Comment:', {
              id: comment.id,
              timestamp: comment.timestamp,
              timestampType: typeof comment.timestamp,
              price: comment.price,
              content: comment.content.substring(0, 30),
              emotion_icon: comment.emotion_icon
            });
          }
        });
        
        setComments(commentsRes.data.comments);
      } else {
        console.log('No comments in response');
        setComments([]);
      }
    } catch (error) {
      console.error('Failed to load comments:', error);
      
      // „Ç®„É©„ÉºÊôÇ„Å´„Éá„É¢„Ç≥„É°„É≥„Éà„ÇíË°®Á§∫
      const demoComments = generateDemoComments();
      setComments(demoComments);
    }
  }, []);

  const loadSentiment = useCallback(async () => {
    try {
      // „Çª„É≥„ÉÅ„É°„É≥„ÉàÂèñÂæóÔºà„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Å™„ÅóÔºâ
      const sentimentRes = await axios.get(`${API_URL}/api/sentiment`);
      console.log('Sentiment data:', sentimentRes.data);
      setSentiment(sentimentRes.data || { buy_percentage: 50, sell_percentage: 50 });
    } catch (error) {
      console.error('Failed to update sentiment:', error);
      setSentiment({ buy_percentage: 60, sell_percentage: 40 });
    }
  }, []);

  const updateChartWithNewPrice = useCallback((newPrice) => {
    setChartData(prevData => {
      if (!prevData || prevData.length === 0) return prevData;
      
      const lastCandle = prevData[prevData.length - 1];
      const now = Math.floor(Date.now() / 1000);
      
      // ÊôÇÈñìÊû†„Å´Âøú„Åò„ÅüÈñìÈöî„ÇíË®àÁÆó
      const intervals = {
        '1m': 60,
        '3m': 180,
        '5m': 300,
        '15m': 900,
        '1H': 3600,
        '4H': 14400,
        '1D': 86400,
        '1W': 604800
      };
      
      const interval = intervals[timeFrame] || 900;
      
      // Êñ∞„Åó„ÅÑ„É≠„Éº„ÇΩ„ÇØË∂≥„Çí‰ΩúÊàê„Åô„Çã„Åã„ÄÅÊó¢Â≠ò„ÅÆ„ÇÇ„ÅÆ„ÇíÊõ¥Êñ∞„Åô„Çã„ÅãÂà§Êñ≠
      if (now - lastCandle.time >= interval) {
        // Êñ∞„Åó„ÅÑ„É≠„Éº„ÇΩ„ÇØË∂≥„ÇíËøΩÂä†
        const newCandle = {
          time: lastCandle.time + interval,
          open: lastCandle.close,
          high: Math.max(lastCandle.close, newPrice),
          low: Math.min(lastCandle.close, newPrice),
          close: newPrice,
          volume: Math.floor(Math.random() * 1000000)
        };
        return [...prevData.slice(-99), newCandle]; // ÊúÄÊñ∞100Êú¨„Çí‰øùÊåÅ
      } else {
        // Êó¢Â≠ò„ÅÆ„É≠„Éº„ÇΩ„ÇØË∂≥„ÇíÊõ¥Êñ∞
        const updatedData = [...prevData];
        const last = updatedData[updatedData.length - 1];
        last.high = Math.max(last.high, newPrice);
        last.low = Math.min(last.low, newPrice);
        last.close = newPrice;
        return updatedData;
      }
    });
  }, [timeFrame]);

  useEffect(() => {
    // WebSocketÊé•Á∂ö„ÇíÂàùÊúüÂåñ
    const wsUrl = API_URL.replace('http', 'ws').replace('https', 'wss');
    console.log('Initializing WebSocket connection to:', `${wsUrl}/ws`);
    
    const ws = new WebSocketService(`${wsUrl}/ws`);
    setWsService(ws);
    
    // Êñ∞„Åó„ÅÑ„Ç≥„É°„É≥„Éà„ÇíÂèó‰ø°
    ws.on('new_comment', (data) => {
      console.log('New comment received via WebSocket:', data);
      console.log('Timestamp type:', typeof data.timestamp);
      
      setComments(prev => {
        // ÈáçË§á„ÇíÈÅø„Åë„Çã
        const exists = prev.find(c => c.id === data.id);
        if (exists) {
          console.log('Comment already exists, skipping');
          return prev;
        }
        
        // Êñ∞„Åó„ÅÑ„Ç≥„É°„É≥„Éà„ÇíËøΩÂä†ÔºàÊúÄÊñ∞„ÅÆ„Ç≥„É°„É≥„Éà„ÇíÂÖàÈ†≠„Å´Ôºâ
        const newComments = [data, ...prev];
        console.log('Total comments after adding new:', newComments.length);
        return newComments;
      });
      
      // „Çª„É≥„ÉÅ„É°„É≥„Éà„ÇÇÊõ¥Êñ∞
      loadSentiment();
    });
    
    // „Ç≥„É°„É≥„Éà‰øùÂ≠ò„ÅÆÁ¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏
    ws.on('comment_saved', (data) => {
      console.log('Comment saved confirmation:', data);
      console.log('Saved timestamp type:', typeof data.timestamp);
      
      // Âç≥Â∫ß„Å´„Ç≥„É°„É≥„Éà„É™„Çπ„Éà„Å´ËøΩÂä†
      setComments(prev => {
        const exists = prev.find(c => c.id === data.id);
        if (!exists) {
          return [data, ...prev];
        }
        return prev;
      });
      
      // „Çª„É≥„ÉÅ„É°„É≥„Éà„ÇíÊõ¥Êñ∞
      loadSentiment();
    });
    
    // „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏
    ws.on('error', (data) => {
      console.error('WebSocket error:', data);
    });
    
    // „Éû„Éº„Ç±„ÉÉ„ÉàÊõ¥Êñ∞
    ws.on('market_update', (data) => {
      console.log('Market update received:', data);
      if (data && data.price) {
        updateChartWithNewPrice(data.price);
      }
    });

    // ÂàùÊúü„Éá„Éº„Çø„ÇíÂèñÂæó
    loadChartData();
    loadComments();
    loadSentiment();
    
    // ÂÆöÊúüÁöÑ„Å´„Éá„Éº„Çø„ÇíÊõ¥Êñ∞Ôºà30Áßí„Åî„Å®Ôºâ
    const intervalId = setInterval(() => {
      loadChartData();
      loadComments();
      loadSentiment();
    }, 30000);
    
    return () => {
      console.log('Cleaning up WebSocket connection');
      clearInterval(intervalId);
      ws.close();
    };
  }, []); // ‰æùÂ≠òÈÖçÂàó„ÇíÁ©∫„Å´„Åó„Å¶ÂàùÂõû„ÅÆ„ÅøÂÆüË°å

  useEffect(() => {
    // ÊôÇÈñìÊû†„ÅåÂ§âÊõ¥„Åï„Çå„Åü„Çâ„ÉÅ„É£„Éº„Éà„Éá„Éº„Çø„ÅÆ„ÅøÂÜçË™≠„ÅøËæº„Åø
    console.log('Timeframe changed to:', timeFrame);
    loadChartData();
  }, [timeFrame, loadChartData]);

  const handleCandleClick = useCallback((candleData) => {
    console.log('Candle clicked with data:', candleData);
    setSelectedCandle(candleData);
    setShowPostModal(true);
  }, []);

  const handlePostComment = async (content, emotionIcon, customPrice) => {
    console.log('Posting comment:', { content, emotionIcon, customPrice });
    
    if (wsService && selectedCandle) {
      const message = {
        type: 'post_comment',
        timestamp: selectedCandle.time,  // „É≠„Éº„ÇΩ„ÇØË∂≥„ÅÆÊôÇÈñì„ÇíÈÄÅ‰ø°ÔºàÁßíÂçò‰Ωç„ÅÆUNIX„Çø„Ç§„É†„Çπ„Çø„É≥„ÉóÔºâ
        price: customPrice || selectedCandle.price,  // „Ç´„Çπ„Çø„É†‰æ°Ê†º„Åæ„Åü„ÅØÈÅ∏Êäû„Åó„Åü‰æ°Ê†º
        content: content,
        emotion_icon: emotionIcon
      };
      
      console.log('Sending WebSocket message:', message);
      console.log('Timestamp being sent:', message.timestamp, 'Type:', typeof message.timestamp);
      wsService.send(message);
    } else {
      console.error('WebSocket service not initialized or candle not selected');
    }
    
    setShowPostModal(false);
    setSelectedCandle(null);
  };

  return (
    <div className="app">
      <header className="app-header">
        <div className="logo">
          <span className="logo-text">üìà „Éä„Çπ„ÉÄ„ÉÉ„ÇØ100ÂÖàÁâ©</span>
        </div>
        
        <TimeFrameSelector 
          selected={timeFrame} 
          onChange={setTimeFrame} 
        />
        
        <PositionIndicator sentiment={sentiment} />
      </header>
      
      {connectionError && (
        <div className="connection-error">
          ‚ö†Ô∏è „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„ÄÇ„Éá„É¢„É¢„Éº„Éâ„ÅßÂÆüË°å‰∏≠„Åß„Åô„ÄÇ
        </div>
      )}
      
      <main className="app-main">
        <Chart 
          data={chartData}
          comments={comments}
          onCandleClick={handleCandleClick}
        />
      </main>
      
      {showPostModal && selectedCandle && (
        <PostModal
          onClose={() => {
            setShowPostModal(false);
            setSelectedCandle(null);
          }}
          onSubmit={handlePostComment}
          candleData={selectedCandle}
        />
      )}
    </div>
  );
}

export default App;